// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: tensorflow/compiler/xla/rpc/xla_service.proto

package rpc

import (
	context "context"
	xla "gitee.com/qciip-icp/tf-serving/tensorflow/compiler/xla"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// XlaServiceClient is the client API for XlaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type XlaServiceClient interface {
	// Unregisters a global allocation.
	//
	// If the handle given is not currently allocated, a NOT_FOUND status is
	// returned.
	Unregister(ctx context.Context, in *xla.UnregisterRequest, opts ...grpc.CallOption) (*xla.UnregisterResponse, error)
	// Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
	// element in the tuple.
	DeconstructTuple(ctx context.Context, in *xla.DeconstructTupleRequest, opts ...grpc.CallOption) (*xla.DeconstructTupleResponse, error)
	// Unpack requests that a global data handle, with a tuple shape, has global
	// data handles created for each of its constituent members. This is the
	// equivalent of the "destructuring assignment" present in various programming
	// languages.
	Unpack(ctx context.Context, in *xla.UnpackRequest, opts ...grpc.CallOption) (*xla.UnpackResponse, error)
	// Requests the shape of the referenced global data.
	GetShape(ctx context.Context, in *xla.GetShapeRequest, opts ...grpc.CallOption) (*xla.GetShapeResponse, error)
	// Requests the statistics of the given computation.
	GetComputationGraphStats(ctx context.Context, in *xla.ComputationGraphStatsRequest, opts ...grpc.CallOption) (*xla.ComputationStatsResponse, error)
	// Loads a variable number of values with a given element type from ColumnIO.
	LoadData(ctx context.Context, in *xla.LoadDataRequest, opts ...grpc.CallOption) (*xla.LoadDataResponse, error)
	// Transfers the given global data to the client in the form of a Literal.
	TransferToClient(ctx context.Context, in *xla.TransferToClientRequest, opts ...grpc.CallOption) (*xla.TransferToClientResponse, error)
	// Transfers the given literal to the server to be stored in a global
	// allocation, which is returned.
	TransferToServer(ctx context.Context, in *xla.TransferToServerRequest, opts ...grpc.CallOption) (*xla.TransferToServerResponse, error)
	// Transfers the given literal to the Infeed buffer of the device.
	TransferToInfeed(ctx context.Context, in *xla.TransferToInfeedRequest, opts ...grpc.CallOption) (*xla.TransferToInfeedResponse, error)
	// Transferred literal from the Outfeed buffer of the device.
	TransferFromOutfeed(ctx context.Context, in *xla.TransferFromOutfeedRequest, opts ...grpc.CallOption) (*xla.TransferFromOutfeedResponse, error)
	// Resets the device, clearing all existing state on the device.
	ResetDevice(ctx context.Context, in *xla.ResetDeviceRequest, opts ...grpc.CallOption) (*xla.ResetDeviceResponse, error)
	// Computes the value of a constant expression. The request contains the
	// computation graph for the constant expression.
	ComputeConstantGraph(ctx context.Context, in *xla.ComputeConstantGraphRequest, opts ...grpc.CallOption) (*xla.ComputeConstantResponse, error)
	// Requests one or more device handles from the target. The returned device
	// handles can be used to specify the device on which to execute computations
	// or transfer data.
	GetDeviceHandles(ctx context.Context, in *xla.GetDeviceHandlesRequest, opts ...grpc.CallOption) (*xla.GetDeviceHandlesResponse, error)
	// Creates a channel handle that can be used to transfer data between
	// two computations via a pair of Send and Recv instructions.
	CreateChannelHandle(ctx context.Context, in *xla.CreateChannelHandleRequest, opts ...grpc.CallOption) (*xla.CreateChannelHandleResponse, error)
	// Compiles the provided computation into executable. Returns the handle of
	// the executable.
	Compile(ctx context.Context, in *xla.CompileRequest, opts ...grpc.CallOption) (*xla.CompileResponse, error)
	// Invokes the provided executable with the provided global data passed as
	// immutable arguments. The request contains the handle to the executable.
	// Returns global data output and execution timing.
	Execute(ctx context.Context, in *xla.ExecuteRequest, opts ...grpc.CallOption) (*xla.ExecuteResponse, error)
	// Invokes the provided list of computations in parallel with the provided
	// global data for each computation. Returns a list of global data output and
	// execution timing.
	ExecuteGraphParallel(ctx context.Context, in *xla.ExecuteGraphParallelRequest, opts ...grpc.CallOption) (*xla.ExecuteParallelResponse, error)
	// Waits until the given execution (aysnchronously launched) is complete, and
	// returns the global data output.
	WaitForExecution(ctx context.Context, in *xla.WaitForExecutionRequest, opts ...grpc.CallOption) (*xla.WaitForExecutionResponse, error)
}

type xlaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewXlaServiceClient(cc grpc.ClientConnInterface) XlaServiceClient {
	return &xlaServiceClient{cc}
}

func (c *xlaServiceClient) Unregister(ctx context.Context, in *xla.UnregisterRequest, opts ...grpc.CallOption) (*xla.UnregisterResponse, error) {
	out := new(xla.UnregisterResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/Unregister", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) DeconstructTuple(ctx context.Context, in *xla.DeconstructTupleRequest, opts ...grpc.CallOption) (*xla.DeconstructTupleResponse, error) {
	out := new(xla.DeconstructTupleResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/DeconstructTuple", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) Unpack(ctx context.Context, in *xla.UnpackRequest, opts ...grpc.CallOption) (*xla.UnpackResponse, error) {
	out := new(xla.UnpackResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/Unpack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) GetShape(ctx context.Context, in *xla.GetShapeRequest, opts ...grpc.CallOption) (*xla.GetShapeResponse, error) {
	out := new(xla.GetShapeResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/GetShape", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) GetComputationGraphStats(ctx context.Context, in *xla.ComputationGraphStatsRequest, opts ...grpc.CallOption) (*xla.ComputationStatsResponse, error) {
	out := new(xla.ComputationStatsResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/GetComputationGraphStats", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) LoadData(ctx context.Context, in *xla.LoadDataRequest, opts ...grpc.CallOption) (*xla.LoadDataResponse, error) {
	out := new(xla.LoadDataResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/LoadData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) TransferToClient(ctx context.Context, in *xla.TransferToClientRequest, opts ...grpc.CallOption) (*xla.TransferToClientResponse, error) {
	out := new(xla.TransferToClientResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/TransferToClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) TransferToServer(ctx context.Context, in *xla.TransferToServerRequest, opts ...grpc.CallOption) (*xla.TransferToServerResponse, error) {
	out := new(xla.TransferToServerResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/TransferToServer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) TransferToInfeed(ctx context.Context, in *xla.TransferToInfeedRequest, opts ...grpc.CallOption) (*xla.TransferToInfeedResponse, error) {
	out := new(xla.TransferToInfeedResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/TransferToInfeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) TransferFromOutfeed(ctx context.Context, in *xla.TransferFromOutfeedRequest, opts ...grpc.CallOption) (*xla.TransferFromOutfeedResponse, error) {
	out := new(xla.TransferFromOutfeedResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/TransferFromOutfeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) ResetDevice(ctx context.Context, in *xla.ResetDeviceRequest, opts ...grpc.CallOption) (*xla.ResetDeviceResponse, error) {
	out := new(xla.ResetDeviceResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/ResetDevice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) ComputeConstantGraph(ctx context.Context, in *xla.ComputeConstantGraphRequest, opts ...grpc.CallOption) (*xla.ComputeConstantResponse, error) {
	out := new(xla.ComputeConstantResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/ComputeConstantGraph", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) GetDeviceHandles(ctx context.Context, in *xla.GetDeviceHandlesRequest, opts ...grpc.CallOption) (*xla.GetDeviceHandlesResponse, error) {
	out := new(xla.GetDeviceHandlesResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/GetDeviceHandles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) CreateChannelHandle(ctx context.Context, in *xla.CreateChannelHandleRequest, opts ...grpc.CallOption) (*xla.CreateChannelHandleResponse, error) {
	out := new(xla.CreateChannelHandleResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/CreateChannelHandle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) Compile(ctx context.Context, in *xla.CompileRequest, opts ...grpc.CallOption) (*xla.CompileResponse, error) {
	out := new(xla.CompileResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/Compile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) Execute(ctx context.Context, in *xla.ExecuteRequest, opts ...grpc.CallOption) (*xla.ExecuteResponse, error) {
	out := new(xla.ExecuteResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/Execute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) ExecuteGraphParallel(ctx context.Context, in *xla.ExecuteGraphParallelRequest, opts ...grpc.CallOption) (*xla.ExecuteParallelResponse, error) {
	out := new(xla.ExecuteParallelResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/ExecuteGraphParallel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xlaServiceClient) WaitForExecution(ctx context.Context, in *xla.WaitForExecutionRequest, opts ...grpc.CallOption) (*xla.WaitForExecutionResponse, error) {
	out := new(xla.WaitForExecutionResponse)
	err := c.cc.Invoke(ctx, "/xla.XlaService/WaitForExecution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// XlaServiceServer is the server API for XlaService service.
// All implementations must embed UnimplementedXlaServiceServer
// for forward compatibility
type XlaServiceServer interface {
	// Unregisters a global allocation.
	//
	// If the handle given is not currently allocated, a NOT_FOUND status is
	// returned.
	Unregister(context.Context, *xla.UnregisterRequest) (*xla.UnregisterResponse, error)
	// Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
	// element in the tuple.
	DeconstructTuple(context.Context, *xla.DeconstructTupleRequest) (*xla.DeconstructTupleResponse, error)
	// Unpack requests that a global data handle, with a tuple shape, has global
	// data handles created for each of its constituent members. This is the
	// equivalent of the "destructuring assignment" present in various programming
	// languages.
	Unpack(context.Context, *xla.UnpackRequest) (*xla.UnpackResponse, error)
	// Requests the shape of the referenced global data.
	GetShape(context.Context, *xla.GetShapeRequest) (*xla.GetShapeResponse, error)
	// Requests the statistics of the given computation.
	GetComputationGraphStats(context.Context, *xla.ComputationGraphStatsRequest) (*xla.ComputationStatsResponse, error)
	// Loads a variable number of values with a given element type from ColumnIO.
	LoadData(context.Context, *xla.LoadDataRequest) (*xla.LoadDataResponse, error)
	// Transfers the given global data to the client in the form of a Literal.
	TransferToClient(context.Context, *xla.TransferToClientRequest) (*xla.TransferToClientResponse, error)
	// Transfers the given literal to the server to be stored in a global
	// allocation, which is returned.
	TransferToServer(context.Context, *xla.TransferToServerRequest) (*xla.TransferToServerResponse, error)
	// Transfers the given literal to the Infeed buffer of the device.
	TransferToInfeed(context.Context, *xla.TransferToInfeedRequest) (*xla.TransferToInfeedResponse, error)
	// Transferred literal from the Outfeed buffer of the device.
	TransferFromOutfeed(context.Context, *xla.TransferFromOutfeedRequest) (*xla.TransferFromOutfeedResponse, error)
	// Resets the device, clearing all existing state on the device.
	ResetDevice(context.Context, *xla.ResetDeviceRequest) (*xla.ResetDeviceResponse, error)
	// Computes the value of a constant expression. The request contains the
	// computation graph for the constant expression.
	ComputeConstantGraph(context.Context, *xla.ComputeConstantGraphRequest) (*xla.ComputeConstantResponse, error)
	// Requests one or more device handles from the target. The returned device
	// handles can be used to specify the device on which to execute computations
	// or transfer data.
	GetDeviceHandles(context.Context, *xla.GetDeviceHandlesRequest) (*xla.GetDeviceHandlesResponse, error)
	// Creates a channel handle that can be used to transfer data between
	// two computations via a pair of Send and Recv instructions.
	CreateChannelHandle(context.Context, *xla.CreateChannelHandleRequest) (*xla.CreateChannelHandleResponse, error)
	// Compiles the provided computation into executable. Returns the handle of
	// the executable.
	Compile(context.Context, *xla.CompileRequest) (*xla.CompileResponse, error)
	// Invokes the provided executable with the provided global data passed as
	// immutable arguments. The request contains the handle to the executable.
	// Returns global data output and execution timing.
	Execute(context.Context, *xla.ExecuteRequest) (*xla.ExecuteResponse, error)
	// Invokes the provided list of computations in parallel with the provided
	// global data for each computation. Returns a list of global data output and
	// execution timing.
	ExecuteGraphParallel(context.Context, *xla.ExecuteGraphParallelRequest) (*xla.ExecuteParallelResponse, error)
	// Waits until the given execution (aysnchronously launched) is complete, and
	// returns the global data output.
	WaitForExecution(context.Context, *xla.WaitForExecutionRequest) (*xla.WaitForExecutionResponse, error)
	mustEmbedUnimplementedXlaServiceServer()
}

// UnimplementedXlaServiceServer must be embedded to have forward compatible implementations.
type UnimplementedXlaServiceServer struct {
}

func (UnimplementedXlaServiceServer) Unregister(context.Context, *xla.UnregisterRequest) (*xla.UnregisterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unregister not implemented")
}
func (UnimplementedXlaServiceServer) DeconstructTuple(context.Context, *xla.DeconstructTupleRequest) (*xla.DeconstructTupleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeconstructTuple not implemented")
}
func (UnimplementedXlaServiceServer) Unpack(context.Context, *xla.UnpackRequest) (*xla.UnpackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unpack not implemented")
}
func (UnimplementedXlaServiceServer) GetShape(context.Context, *xla.GetShapeRequest) (*xla.GetShapeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShape not implemented")
}
func (UnimplementedXlaServiceServer) GetComputationGraphStats(context.Context, *xla.ComputationGraphStatsRequest) (*xla.ComputationStatsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComputationGraphStats not implemented")
}
func (UnimplementedXlaServiceServer) LoadData(context.Context, *xla.LoadDataRequest) (*xla.LoadDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadData not implemented")
}
func (UnimplementedXlaServiceServer) TransferToClient(context.Context, *xla.TransferToClientRequest) (*xla.TransferToClientResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToClient not implemented")
}
func (UnimplementedXlaServiceServer) TransferToServer(context.Context, *xla.TransferToServerRequest) (*xla.TransferToServerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToServer not implemented")
}
func (UnimplementedXlaServiceServer) TransferToInfeed(context.Context, *xla.TransferToInfeedRequest) (*xla.TransferToInfeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToInfeed not implemented")
}
func (UnimplementedXlaServiceServer) TransferFromOutfeed(context.Context, *xla.TransferFromOutfeedRequest) (*xla.TransferFromOutfeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferFromOutfeed not implemented")
}
func (UnimplementedXlaServiceServer) ResetDevice(context.Context, *xla.ResetDeviceRequest) (*xla.ResetDeviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetDevice not implemented")
}
func (UnimplementedXlaServiceServer) ComputeConstantGraph(context.Context, *xla.ComputeConstantGraphRequest) (*xla.ComputeConstantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComputeConstantGraph not implemented")
}
func (UnimplementedXlaServiceServer) GetDeviceHandles(context.Context, *xla.GetDeviceHandlesRequest) (*xla.GetDeviceHandlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceHandles not implemented")
}
func (UnimplementedXlaServiceServer) CreateChannelHandle(context.Context, *xla.CreateChannelHandleRequest) (*xla.CreateChannelHandleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChannelHandle not implemented")
}
func (UnimplementedXlaServiceServer) Compile(context.Context, *xla.CompileRequest) (*xla.CompileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compile not implemented")
}
func (UnimplementedXlaServiceServer) Execute(context.Context, *xla.ExecuteRequest) (*xla.ExecuteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Execute not implemented")
}
func (UnimplementedXlaServiceServer) ExecuteGraphParallel(context.Context, *xla.ExecuteGraphParallelRequest) (*xla.ExecuteParallelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteGraphParallel not implemented")
}
func (UnimplementedXlaServiceServer) WaitForExecution(context.Context, *xla.WaitForExecutionRequest) (*xla.WaitForExecutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForExecution not implemented")
}
func (UnimplementedXlaServiceServer) mustEmbedUnimplementedXlaServiceServer() {}

// UnsafeXlaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to XlaServiceServer will
// result in compilation errors.
type UnsafeXlaServiceServer interface {
	mustEmbedUnimplementedXlaServiceServer()
}

func RegisterXlaServiceServer(s grpc.ServiceRegistrar, srv XlaServiceServer) {
	s.RegisterService(&XlaService_ServiceDesc, srv)
}

func _XlaService_Unregister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.UnregisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).Unregister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/Unregister",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).Unregister(ctx, req.(*xla.UnregisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_DeconstructTuple_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.DeconstructTupleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).DeconstructTuple(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/DeconstructTuple",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).DeconstructTuple(ctx, req.(*xla.DeconstructTupleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_Unpack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.UnpackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).Unpack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/Unpack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).Unpack(ctx, req.(*xla.UnpackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_GetShape_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.GetShapeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).GetShape(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/GetShape",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).GetShape(ctx, req.(*xla.GetShapeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_GetComputationGraphStats_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.ComputationGraphStatsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).GetComputationGraphStats(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/GetComputationGraphStats",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).GetComputationGraphStats(ctx, req.(*xla.ComputationGraphStatsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_LoadData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.LoadDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).LoadData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/LoadData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).LoadData(ctx, req.(*xla.LoadDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_TransferToClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.TransferToClientRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).TransferToClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/TransferToClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).TransferToClient(ctx, req.(*xla.TransferToClientRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_TransferToServer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.TransferToServerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).TransferToServer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/TransferToServer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).TransferToServer(ctx, req.(*xla.TransferToServerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_TransferToInfeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.TransferToInfeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).TransferToInfeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/TransferToInfeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).TransferToInfeed(ctx, req.(*xla.TransferToInfeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_TransferFromOutfeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.TransferFromOutfeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).TransferFromOutfeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/TransferFromOutfeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).TransferFromOutfeed(ctx, req.(*xla.TransferFromOutfeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_ResetDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.ResetDeviceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).ResetDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/ResetDevice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).ResetDevice(ctx, req.(*xla.ResetDeviceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_ComputeConstantGraph_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.ComputeConstantGraphRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).ComputeConstantGraph(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/ComputeConstantGraph",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).ComputeConstantGraph(ctx, req.(*xla.ComputeConstantGraphRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_GetDeviceHandles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.GetDeviceHandlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).GetDeviceHandles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/GetDeviceHandles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).GetDeviceHandles(ctx, req.(*xla.GetDeviceHandlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_CreateChannelHandle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.CreateChannelHandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).CreateChannelHandle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/CreateChannelHandle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).CreateChannelHandle(ctx, req.(*xla.CreateChannelHandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_Compile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.CompileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).Compile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/Compile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).Compile(ctx, req.(*xla.CompileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_Execute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.ExecuteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).Execute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/Execute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).Execute(ctx, req.(*xla.ExecuteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_ExecuteGraphParallel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.ExecuteGraphParallelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).ExecuteGraphParallel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/ExecuteGraphParallel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).ExecuteGraphParallel(ctx, req.(*xla.ExecuteGraphParallelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XlaService_WaitForExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(xla.WaitForExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XlaServiceServer).WaitForExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/xla.XlaService/WaitForExecution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XlaServiceServer).WaitForExecution(ctx, req.(*xla.WaitForExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// XlaService_ServiceDesc is the grpc.ServiceDesc for XlaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var XlaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "xla.XlaService",
	HandlerType: (*XlaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Unregister",
			Handler:    _XlaService_Unregister_Handler,
		},
		{
			MethodName: "DeconstructTuple",
			Handler:    _XlaService_DeconstructTuple_Handler,
		},
		{
			MethodName: "Unpack",
			Handler:    _XlaService_Unpack_Handler,
		},
		{
			MethodName: "GetShape",
			Handler:    _XlaService_GetShape_Handler,
		},
		{
			MethodName: "GetComputationGraphStats",
			Handler:    _XlaService_GetComputationGraphStats_Handler,
		},
		{
			MethodName: "LoadData",
			Handler:    _XlaService_LoadData_Handler,
		},
		{
			MethodName: "TransferToClient",
			Handler:    _XlaService_TransferToClient_Handler,
		},
		{
			MethodName: "TransferToServer",
			Handler:    _XlaService_TransferToServer_Handler,
		},
		{
			MethodName: "TransferToInfeed",
			Handler:    _XlaService_TransferToInfeed_Handler,
		},
		{
			MethodName: "TransferFromOutfeed",
			Handler:    _XlaService_TransferFromOutfeed_Handler,
		},
		{
			MethodName: "ResetDevice",
			Handler:    _XlaService_ResetDevice_Handler,
		},
		{
			MethodName: "ComputeConstantGraph",
			Handler:    _XlaService_ComputeConstantGraph_Handler,
		},
		{
			MethodName: "GetDeviceHandles",
			Handler:    _XlaService_GetDeviceHandles_Handler,
		},
		{
			MethodName: "CreateChannelHandle",
			Handler:    _XlaService_CreateChannelHandle_Handler,
		},
		{
			MethodName: "Compile",
			Handler:    _XlaService_Compile_Handler,
		},
		{
			MethodName: "Execute",
			Handler:    _XlaService_Execute_Handler,
		},
		{
			MethodName: "ExecuteGraphParallel",
			Handler:    _XlaService_ExecuteGraphParallel_Handler,
		},
		{
			MethodName: "WaitForExecution",
			Handler:    _XlaService_WaitForExecution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tensorflow/compiler/xla/rpc/xla_service.proto",
}
