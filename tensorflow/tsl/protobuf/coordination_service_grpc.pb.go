// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             (unknown)
// source: tensorflow/tsl/protobuf/coordination_service.proto

package protobuf

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CoordinationServiceClient is the client API for CoordinationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoordinationServiceClient interface {
	// Register task to coordination service so that the service starts to track
	// liveness of the task. RPC blocks and returns only when it registers to
	// the service successfully, or error happens in the registering process.
	RegisterTask(ctx context.Context, in *RegisterTaskRequest, opts ...grpc.CallOption) (*RegisterTaskResponse, error)
	// Heartbeat message from task to coordination service. Heartbeat is sent from
	// a task to refresh its timestamp on leader to avoid it becoming stale.
	// RPC responds immediately after refreshing the timestamp on leader.
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Wait for all tasks in the cluster to be up and running. The RPC request
	// only gets responded when all tasks have registered, or some error occurs.
	WaitForAllTasks(ctx context.Context, in *WaitForAllTasksRequest, opts ...grpc.CallOption) (*WaitForAllTasksResponse, error)
	// Disconnects task from the service. If `shutdown_barrier_timeout_in_ms` is
	// specified in the config, blocks until all tasks reach the barrier before
	// disconnecting together. If the barrier times out, tasks at the barrier will
	// still disconnect, while an error is reported to tasks that did not reach
	// the barrier on time.
	ShutdownTask(ctx context.Context, in *ShutdownTaskRequest, opts ...grpc.CallOption) (*ShutdownTaskResponse, error)
	// Disconnects task from the service if it is in an ERROR state, thereby
	// allowing it to reconnect via RegisterTask() in the future.
	ResetTask(ctx context.Context, in *ResetTaskRequest, opts ...grpc.CallOption) (*ResetTaskResponse, error)
	// Report error to the task. RPC sets the receiving instance of coordination
	// service agent to error state permanently.
	// TODO(b/195990880): Consider splitting this into a different RPC service.
	ReportErrorToTask(ctx context.Context, in *ReportErrorToTaskRequest, opts ...grpc.CallOption) (*ReportErrorToTaskResponse, error)
	// Report task error to coordination service. RPC sets the service-side task
	// state to error, and propagate the error to other tasks in the cluster.
	ReportErrorToService(ctx context.Context, in *ReportErrorToServiceRequest, opts ...grpc.CallOption) (*ReportErrorToServiceResponse, error)
	// Get the state of a remote task. Specifically, RPC returns a
	// CoordinatedTaskState, and if the task is in an error status, returns a
	// non-OK error code, non-empty error message and error payload.
	GetTaskState(ctx context.Context, in *GetTaskStateRequest, opts ...grpc.CallOption) (*GetTaskStateResponse, error)
	// Insert configuration key-value that will be accessible to all cluster
	// tasks. The key can be formatted as Unix file path with hierarchy. The
	// coordination service key-value store should only be used for cluster
	// configuration data.
	InsertKeyValue(ctx context.Context, in *InsertKeyValueRequest, opts ...grpc.CallOption) (*InsertKeyValueResponse, error)
	// Get configuration key-value. The request blocks until the key-value data
	// becomes available (i.e., set by a task in the cluster).
	GetKeyValue(ctx context.Context, in *GetKeyValueRequest, opts ...grpc.CallOption) (*GetKeyValueResponse, error)
	// Get configuration key-value. The request does not block, but returns an
	// error if the requested key does not exist.
	TryGetKeyValue(ctx context.Context, in *TryGetKeyValueRequest, opts ...grpc.CallOption) (*TryGetKeyValueResponse, error)
	// Same as GetKeyValue, but returns all values that have keys which are
	// prefixed with the directory key.
	GetKeyValueDir(ctx context.Context, in *GetKeyValueDirRequest, opts ...grpc.CallOption) (*GetKeyValueDirResponse, error)
	// Delete configuration key-value. If is_directory is set in request,
	// recursively clean up all key-values under the path specified by `key`.
	DeleteKeyValue(ctx context.Context, in *DeleteKeyValueRequest, opts ...grpc.CallOption) (*DeleteKeyValueResponse, error)
	// Blocks until all (or a subset of) tasks are at the barrier or the barrier
	// fails.
	//
	// `barrier_id` should be unique across barriers. Once the barrier has passed
	// or failed, subsequent calls will not block, and immediately respond with
	// the previous response.
	//
	// The first WaitAtBarrier() call received by the service for a particular
	// barrier id is special in that it determines the barrier deadline based on
	// timeout duration.
	// However, if subsequent calls by different agents specify a different set of
	// `tasks` for the same `barrier_id`, the barrier will fail instantly.
	//
	// If no tasks are specified (default), the barrier will block for all the
	// connected tasks.
	//
	// Possible service errors:
	//   - DeadlineExceeded: Timed out waiting for specified tasks at the barrier.
	//      Deadline is determined by the server timestamp when it receives the
	//      first WaitAtBarrier() + timeout duration.
	//   - Cancelled: One of the tasks called CancelBarrier().
	//   - Aborted: Service is shutting down.
	//   - Internal: Any participating task is in ERROR state.
	//   - InvalidArgument: (1) Conflicting tasks specified by different agents
	//       for the same barrier, (2) one of the participating tasks is not in
	//       the cluster, or (3) task making the request is not included in the
	//       list of participating tasks.
	Barrier(ctx context.Context, in *BarrierRequest, opts ...grpc.CallOption) (*BarrierResponse, error)
	// Aborts the barrier if it is ongoing.
	// Current and future WaitAtBarrier() calls with the same id will return a
	// CANCELLED error status.
	// Possible service errors:
	//   - FailedPrecondition: Barrier has already been passed.
	CancelBarrier(ctx context.Context, in *CancelBarrierRequest, opts ...grpc.CallOption) (*CancelBarrierResponse, error)
}

type coordinationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCoordinationServiceClient(cc grpc.ClientConnInterface) CoordinationServiceClient {
	return &coordinationServiceClient{cc}
}

func (c *coordinationServiceClient) RegisterTask(ctx context.Context, in *RegisterTaskRequest, opts ...grpc.CallOption) (*RegisterTaskResponse, error) {
	out := new(RegisterTaskResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/RegisterTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/Heartbeat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) WaitForAllTasks(ctx context.Context, in *WaitForAllTasksRequest, opts ...grpc.CallOption) (*WaitForAllTasksResponse, error) {
	out := new(WaitForAllTasksResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/WaitForAllTasks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) ShutdownTask(ctx context.Context, in *ShutdownTaskRequest, opts ...grpc.CallOption) (*ShutdownTaskResponse, error) {
	out := new(ShutdownTaskResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/ShutdownTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) ResetTask(ctx context.Context, in *ResetTaskRequest, opts ...grpc.CallOption) (*ResetTaskResponse, error) {
	out := new(ResetTaskResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/ResetTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) ReportErrorToTask(ctx context.Context, in *ReportErrorToTaskRequest, opts ...grpc.CallOption) (*ReportErrorToTaskResponse, error) {
	out := new(ReportErrorToTaskResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/ReportErrorToTask", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) ReportErrorToService(ctx context.Context, in *ReportErrorToServiceRequest, opts ...grpc.CallOption) (*ReportErrorToServiceResponse, error) {
	out := new(ReportErrorToServiceResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/ReportErrorToService", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) GetTaskState(ctx context.Context, in *GetTaskStateRequest, opts ...grpc.CallOption) (*GetTaskStateResponse, error) {
	out := new(GetTaskStateResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/GetTaskState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) InsertKeyValue(ctx context.Context, in *InsertKeyValueRequest, opts ...grpc.CallOption) (*InsertKeyValueResponse, error) {
	out := new(InsertKeyValueResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/InsertKeyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) GetKeyValue(ctx context.Context, in *GetKeyValueRequest, opts ...grpc.CallOption) (*GetKeyValueResponse, error) {
	out := new(GetKeyValueResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/GetKeyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) TryGetKeyValue(ctx context.Context, in *TryGetKeyValueRequest, opts ...grpc.CallOption) (*TryGetKeyValueResponse, error) {
	out := new(TryGetKeyValueResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/TryGetKeyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) GetKeyValueDir(ctx context.Context, in *GetKeyValueDirRequest, opts ...grpc.CallOption) (*GetKeyValueDirResponse, error) {
	out := new(GetKeyValueDirResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/GetKeyValueDir", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) DeleteKeyValue(ctx context.Context, in *DeleteKeyValueRequest, opts ...grpc.CallOption) (*DeleteKeyValueResponse, error) {
	out := new(DeleteKeyValueResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/DeleteKeyValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) Barrier(ctx context.Context, in *BarrierRequest, opts ...grpc.CallOption) (*BarrierResponse, error) {
	out := new(BarrierResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/Barrier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coordinationServiceClient) CancelBarrier(ctx context.Context, in *CancelBarrierRequest, opts ...grpc.CallOption) (*CancelBarrierResponse, error) {
	out := new(CancelBarrierResponse)
	err := c.cc.Invoke(ctx, "/tensorflow.CoordinationService/CancelBarrier", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoordinationServiceServer is the server API for CoordinationService service.
// All implementations must embed UnimplementedCoordinationServiceServer
// for forward compatibility
type CoordinationServiceServer interface {
	// Register task to coordination service so that the service starts to track
	// liveness of the task. RPC blocks and returns only when it registers to
	// the service successfully, or error happens in the registering process.
	RegisterTask(context.Context, *RegisterTaskRequest) (*RegisterTaskResponse, error)
	// Heartbeat message from task to coordination service. Heartbeat is sent from
	// a task to refresh its timestamp on leader to avoid it becoming stale.
	// RPC responds immediately after refreshing the timestamp on leader.
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Wait for all tasks in the cluster to be up and running. The RPC request
	// only gets responded when all tasks have registered, or some error occurs.
	WaitForAllTasks(context.Context, *WaitForAllTasksRequest) (*WaitForAllTasksResponse, error)
	// Disconnects task from the service. If `shutdown_barrier_timeout_in_ms` is
	// specified in the config, blocks until all tasks reach the barrier before
	// disconnecting together. If the barrier times out, tasks at the barrier will
	// still disconnect, while an error is reported to tasks that did not reach
	// the barrier on time.
	ShutdownTask(context.Context, *ShutdownTaskRequest) (*ShutdownTaskResponse, error)
	// Disconnects task from the service if it is in an ERROR state, thereby
	// allowing it to reconnect via RegisterTask() in the future.
	ResetTask(context.Context, *ResetTaskRequest) (*ResetTaskResponse, error)
	// Report error to the task. RPC sets the receiving instance of coordination
	// service agent to error state permanently.
	// TODO(b/195990880): Consider splitting this into a different RPC service.
	ReportErrorToTask(context.Context, *ReportErrorToTaskRequest) (*ReportErrorToTaskResponse, error)
	// Report task error to coordination service. RPC sets the service-side task
	// state to error, and propagate the error to other tasks in the cluster.
	ReportErrorToService(context.Context, *ReportErrorToServiceRequest) (*ReportErrorToServiceResponse, error)
	// Get the state of a remote task. Specifically, RPC returns a
	// CoordinatedTaskState, and if the task is in an error status, returns a
	// non-OK error code, non-empty error message and error payload.
	GetTaskState(context.Context, *GetTaskStateRequest) (*GetTaskStateResponse, error)
	// Insert configuration key-value that will be accessible to all cluster
	// tasks. The key can be formatted as Unix file path with hierarchy. The
	// coordination service key-value store should only be used for cluster
	// configuration data.
	InsertKeyValue(context.Context, *InsertKeyValueRequest) (*InsertKeyValueResponse, error)
	// Get configuration key-value. The request blocks until the key-value data
	// becomes available (i.e., set by a task in the cluster).
	GetKeyValue(context.Context, *GetKeyValueRequest) (*GetKeyValueResponse, error)
	// Get configuration key-value. The request does not block, but returns an
	// error if the requested key does not exist.
	TryGetKeyValue(context.Context, *TryGetKeyValueRequest) (*TryGetKeyValueResponse, error)
	// Same as GetKeyValue, but returns all values that have keys which are
	// prefixed with the directory key.
	GetKeyValueDir(context.Context, *GetKeyValueDirRequest) (*GetKeyValueDirResponse, error)
	// Delete configuration key-value. If is_directory is set in request,
	// recursively clean up all key-values under the path specified by `key`.
	DeleteKeyValue(context.Context, *DeleteKeyValueRequest) (*DeleteKeyValueResponse, error)
	// Blocks until all (or a subset of) tasks are at the barrier or the barrier
	// fails.
	//
	// `barrier_id` should be unique across barriers. Once the barrier has passed
	// or failed, subsequent calls will not block, and immediately respond with
	// the previous response.
	//
	// The first WaitAtBarrier() call received by the service for a particular
	// barrier id is special in that it determines the barrier deadline based on
	// timeout duration.
	// However, if subsequent calls by different agents specify a different set of
	// `tasks` for the same `barrier_id`, the barrier will fail instantly.
	//
	// If no tasks are specified (default), the barrier will block for all the
	// connected tasks.
	//
	// Possible service errors:
	//   - DeadlineExceeded: Timed out waiting for specified tasks at the barrier.
	//      Deadline is determined by the server timestamp when it receives the
	//      first WaitAtBarrier() + timeout duration.
	//   - Cancelled: One of the tasks called CancelBarrier().
	//   - Aborted: Service is shutting down.
	//   - Internal: Any participating task is in ERROR state.
	//   - InvalidArgument: (1) Conflicting tasks specified by different agents
	//       for the same barrier, (2) one of the participating tasks is not in
	//       the cluster, or (3) task making the request is not included in the
	//       list of participating tasks.
	Barrier(context.Context, *BarrierRequest) (*BarrierResponse, error)
	// Aborts the barrier if it is ongoing.
	// Current and future WaitAtBarrier() calls with the same id will return a
	// CANCELLED error status.
	// Possible service errors:
	//   - FailedPrecondition: Barrier has already been passed.
	CancelBarrier(context.Context, *CancelBarrierRequest) (*CancelBarrierResponse, error)
	mustEmbedUnimplementedCoordinationServiceServer()
}

// UnimplementedCoordinationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCoordinationServiceServer struct {
}

func (UnimplementedCoordinationServiceServer) RegisterTask(context.Context, *RegisterTaskRequest) (*RegisterTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterTask not implemented")
}
func (UnimplementedCoordinationServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedCoordinationServiceServer) WaitForAllTasks(context.Context, *WaitForAllTasksRequest) (*WaitForAllTasksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WaitForAllTasks not implemented")
}
func (UnimplementedCoordinationServiceServer) ShutdownTask(context.Context, *ShutdownTaskRequest) (*ShutdownTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShutdownTask not implemented")
}
func (UnimplementedCoordinationServiceServer) ResetTask(context.Context, *ResetTaskRequest) (*ResetTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetTask not implemented")
}
func (UnimplementedCoordinationServiceServer) ReportErrorToTask(context.Context, *ReportErrorToTaskRequest) (*ReportErrorToTaskResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportErrorToTask not implemented")
}
func (UnimplementedCoordinationServiceServer) ReportErrorToService(context.Context, *ReportErrorToServiceRequest) (*ReportErrorToServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportErrorToService not implemented")
}
func (UnimplementedCoordinationServiceServer) GetTaskState(context.Context, *GetTaskStateRequest) (*GetTaskStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTaskState not implemented")
}
func (UnimplementedCoordinationServiceServer) InsertKeyValue(context.Context, *InsertKeyValueRequest) (*InsertKeyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertKeyValue not implemented")
}
func (UnimplementedCoordinationServiceServer) GetKeyValue(context.Context, *GetKeyValueRequest) (*GetKeyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyValue not implemented")
}
func (UnimplementedCoordinationServiceServer) TryGetKeyValue(context.Context, *TryGetKeyValueRequest) (*TryGetKeyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TryGetKeyValue not implemented")
}
func (UnimplementedCoordinationServiceServer) GetKeyValueDir(context.Context, *GetKeyValueDirRequest) (*GetKeyValueDirResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetKeyValueDir not implemented")
}
func (UnimplementedCoordinationServiceServer) DeleteKeyValue(context.Context, *DeleteKeyValueRequest) (*DeleteKeyValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteKeyValue not implemented")
}
func (UnimplementedCoordinationServiceServer) Barrier(context.Context, *BarrierRequest) (*BarrierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Barrier not implemented")
}
func (UnimplementedCoordinationServiceServer) CancelBarrier(context.Context, *CancelBarrierRequest) (*CancelBarrierResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelBarrier not implemented")
}
func (UnimplementedCoordinationServiceServer) mustEmbedUnimplementedCoordinationServiceServer() {}

// UnsafeCoordinationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoordinationServiceServer will
// result in compilation errors.
type UnsafeCoordinationServiceServer interface {
	mustEmbedUnimplementedCoordinationServiceServer()
}

func RegisterCoordinationServiceServer(s grpc.ServiceRegistrar, srv CoordinationServiceServer) {
	s.RegisterService(&CoordinationService_ServiceDesc, srv)
}

func _CoordinationService_RegisterTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).RegisterTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/RegisterTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).RegisterTask(ctx, req.(*RegisterTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/Heartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_WaitForAllTasks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitForAllTasksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).WaitForAllTasks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/WaitForAllTasks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).WaitForAllTasks(ctx, req.(*WaitForAllTasksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_ShutdownTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShutdownTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).ShutdownTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/ShutdownTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).ShutdownTask(ctx, req.(*ShutdownTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_ResetTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).ResetTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/ResetTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).ResetTask(ctx, req.(*ResetTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_ReportErrorToTask_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportErrorToTaskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).ReportErrorToTask(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/ReportErrorToTask",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).ReportErrorToTask(ctx, req.(*ReportErrorToTaskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_ReportErrorToService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportErrorToServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).ReportErrorToService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/ReportErrorToService",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).ReportErrorToService(ctx, req.(*ReportErrorToServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_GetTaskState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTaskStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).GetTaskState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/GetTaskState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).GetTaskState(ctx, req.(*GetTaskStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_InsertKeyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertKeyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).InsertKeyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/InsertKeyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).InsertKeyValue(ctx, req.(*InsertKeyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_GetKeyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).GetKeyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/GetKeyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).GetKeyValue(ctx, req.(*GetKeyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_TryGetKeyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TryGetKeyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).TryGetKeyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/TryGetKeyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).TryGetKeyValue(ctx, req.(*TryGetKeyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_GetKeyValueDir_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetKeyValueDirRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).GetKeyValueDir(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/GetKeyValueDir",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).GetKeyValueDir(ctx, req.(*GetKeyValueDirRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_DeleteKeyValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKeyValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).DeleteKeyValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/DeleteKeyValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).DeleteKeyValue(ctx, req.(*DeleteKeyValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_Barrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).Barrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/Barrier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).Barrier(ctx, req.(*BarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CoordinationService_CancelBarrier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelBarrierRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoordinationServiceServer).CancelBarrier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/tensorflow.CoordinationService/CancelBarrier",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoordinationServiceServer).CancelBarrier(ctx, req.(*CancelBarrierRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CoordinationService_ServiceDesc is the grpc.ServiceDesc for CoordinationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CoordinationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tensorflow.CoordinationService",
	HandlerType: (*CoordinationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterTask",
			Handler:    _CoordinationService_RegisterTask_Handler,
		},
		{
			MethodName: "Heartbeat",
			Handler:    _CoordinationService_Heartbeat_Handler,
		},
		{
			MethodName: "WaitForAllTasks",
			Handler:    _CoordinationService_WaitForAllTasks_Handler,
		},
		{
			MethodName: "ShutdownTask",
			Handler:    _CoordinationService_ShutdownTask_Handler,
		},
		{
			MethodName: "ResetTask",
			Handler:    _CoordinationService_ResetTask_Handler,
		},
		{
			MethodName: "ReportErrorToTask",
			Handler:    _CoordinationService_ReportErrorToTask_Handler,
		},
		{
			MethodName: "ReportErrorToService",
			Handler:    _CoordinationService_ReportErrorToService_Handler,
		},
		{
			MethodName: "GetTaskState",
			Handler:    _CoordinationService_GetTaskState_Handler,
		},
		{
			MethodName: "InsertKeyValue",
			Handler:    _CoordinationService_InsertKeyValue_Handler,
		},
		{
			MethodName: "GetKeyValue",
			Handler:    _CoordinationService_GetKeyValue_Handler,
		},
		{
			MethodName: "TryGetKeyValue",
			Handler:    _CoordinationService_TryGetKeyValue_Handler,
		},
		{
			MethodName: "GetKeyValueDir",
			Handler:    _CoordinationService_GetKeyValueDir_Handler,
		},
		{
			MethodName: "DeleteKeyValue",
			Handler:    _CoordinationService_DeleteKeyValue_Handler,
		},
		{
			MethodName: "Barrier",
			Handler:    _CoordinationService_Barrier_Handler,
		},
		{
			MethodName: "CancelBarrier",
			Handler:    _CoordinationService_CancelBarrier_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "tensorflow/tsl/protobuf/coordination_service.proto",
}
